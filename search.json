[{"title":"Flask-2-Jinja2模板","path":"/2024/05/21/Flask-2-Jinja2模板/","content":"模板基础为什么要模板原则上来讲使用如下代码是可以写出任意网站的 1234567891011from flask import Flaskapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index(): return &#x27;&lt;h1&gt;这是标题&lt;/h1&gt;&lt;p&gt;这是内容&lt;/p&gt;&#x27;if __name__ == &#x27;__main__&#x27;: app.config.from_pyfile(&#x27;settings.py&#x27;) app.run() 但这显然不是好的办法，因此需要模板。 模板的简单使用Flask 种使用的是 Jinja2 模板。","tags":["Python","服务器端","Flask","Web 框架"],"categories":["Python","Web 框架","Flask"]},{"title":"Flask(1)-视图基础及URL","path":"/2024/05/12/Flask-1-视图基础及URL/","content":"Flask 入门Flask 可用于网站、公众号、APP、小程序的后端部分开发。 Flask 路由部分使用 Werkzeug 模块，模板引擎使用 Jinja2。 除此以外，其他常用的插件还有： 名称 介绍 Flask-SQLalchemy 操作数据库 Flask-script 插入脚本 Flask-migrate 管理迁移数据库 Flask-Session Session存储方式指定 Flask-WTF 表单 Flask-Mail 邮件 Flask-Bable 提供国际化和本地化支持，翻译 Flask-Login 认证用户状态 Flask-OpenID 认证 Flask-RESTful 开发REST API的工具 Flask-Bootstrap 集成前端Twitter Bootstrap框架 Flask-Moment 本地化日期和时间 Flask-Admin 简单而可扩展的管理接口的框架 中文文档 英文文档 Flask 的第一个应用地址安装 FLask： 1pip install flask 第一个Flask程序: 12345678910111213141516# 引入 Flask 对象，用于创建 web 应用对象from flask import Flask# 创建对象app = Flask(__name__)# 配置路由@app.route(&#x27;/index&#x27;)def index(): return &#x27;尚学堂&#x27;if __name__ == &#x27;__main__&#x27;: # 启动 web 应用（默认端口为 5000） app.run() # 将端口改为 8000 # app.run(port=8000) Flask 运行方式如果需要使得其他计算机可以访问 Flask 启动的 web 应用，应将 Flask 启动 web 应用的代码改为： 1app.run(host=&quot;0.0.0.0&quot;, port=8000) 此时运行程序会给出两个可以使用的地址： 还可以使用命令行启动 Flask： 1234# 需要在系统中设置名为 FLASK_APP 的环境变量，用于指明启动哪个 Flask 服务$ export FLASK_APP=helloworld$ flask run -h 0.0.0.0 -p 8000* Running on http://127.0.0.1:5000/ DEBUG 模式当程序中出现错误，如： 123456@app.route(&#x27;/index&#x27;)def index(): a = 0 b = 1 c = b/a return &#x27;尚学堂&#x27; 此时浏览器显示为： 此时需要开启 DEBUG 模式，方法为： 1app.run(debug=True) 此时，网页上就会显示出错误： 除此以外，DEBUG 模式还可以实现 ”修改代码后，网页可以刷新看效果“ 的效果。 除了以上打开 DEBUG 模式的方法，还可以： 12app.debug = Trueapp.run() Flask 参数的加载以 DEBUG 模式为例，来看看设置 Flask 参数的几种方式： 第1种、运行时传递参数 1app.run(debug = True) 第2种、通过设置 app 的属性 12app.debug = Trueapp.run() 第3种、修改配置参数 123app.config.update(DEBUG=True)# app.config[&#x27;DEBUG&#x27;] = Trueapp.run() 第4种、通过 mapping 加载 12app.config.from_mapping(&#123;&#x27;DEBUG&#x27;:True&#125;)app.run() 第5种、通过配置对象设置config 1234class Config:\tDEBUG = Trueapp.config.from_object(config)app.run() 第6种、将配置写在独立文件中 config.py1DEBUG = True config.json1&#123;&quot;DEBUG&quot;:&quot;True&quot;&#125; app.py12app.config.from_pyfile(&#x27;config.py&#x27;)app.config.from_json(&#x27;config.json&#x27;) 第7种、通过环境变量设置 添加环境变量 DEBUG = True 1app.config.from_envvar(&#x27;DEBUG&#x27;) 推荐使用第六种方式中的 config.py 配置文件 Flask 动态路由URL 路径参数比如，请求的地址为 /users/10011，其中 10011是用户的编号，此时想要获取这个编号，并进一步处理： 12345@app.route(&#x27;/users/&lt;user_id&gt;&#x27;)def user_info(user_id): print(type(user_id)) # 获取 user_id 后，到数据库进行查询，并形成结果，等待输出 return &#x27;hello user&#123;&#125;&#x27;.format(user_id) 此时地址中的用户编号就赋值给了 user_id 这个变量。 路径参数的类型默认 Flask 将路径参数当作字符串处理。 要改变路径参数，用如下方法： 1234@app.route(&#x27;/users/&lt;int:user_id&gt;&#x27;)def user_info(user_id): print(type(user_id)) return &#x27;hello user&#123;&#125;&#x27;.format(user_id) 除了 int 以外，还有 string、float、path、uuid、any 可以用于路径参数。 如果输入的参数无法匹配路径参数的类型，将作为没有匹配到路径，也就是 not found 错误。比如：路由为 @app.route(&#39;/users/&lt;int:user_id&gt;&#39;)，而输入的路径为 http://127.0.0.1:5000/users/111.11，则认为没有对应的路由。 path 类型 再如：路由为 @app.route(&#39;/path/&lt;string:path_id&gt;&#39;)，而输入的路径为 http://127.0.0.1:5000/path/a/b/c，想法是 path_id 被赋值为 a/b/c，但结果是 Not Found。此时就需要类型 path 的路径参数了。 将代码改为 1234@app.route(&#x27;/path/&lt;path:path_id&gt;&#x27;)def user_info(path_id): print(type(path_id)) return &#x27;path:&#123;&#125;&#x27;.format(path_id) 输入的路径为 http://127.0.0.1:5000/path/a/b/c，此时 path_id 被赋值为 a/b/c了。 UUID 类型 如果代码为： 1234@app.route(&#x27;/uuid/&lt;uuid:uuid_id&gt;&#x27;)def user_info(uuid_id): print(type(uuid_id)) return &#x27;path:&#123;&#125;&#x27;.format(uuid_id) 此时路径参数的类型是 UUID。 注意：UUID 是由固定格式的，比如当前路径为 http://127.0.0.1:5000/path/123就无法正确匹配，会 not found。 如果路径为 http://127.0.0.1:5000/uuid/d22ad6c3-bb64-4b9c-b1c0-5b961f0d4bbb 则匹配到的 UUID 为 d22ad6c3-bb64-4b9c-b1c0-5b961f0d4bbb any 类型 假设有多个路径为 /user/id、/item/id、/article/id，我们发现其结构类似，此时可以使用 any 类型来处理，代码如下： 123456@app.route(&#x27;/&lt;any(user, item):tmp&gt;/&lt;int:id&gt;&#x27;)def user_info(tmp, id): if tmp == &quot;user&quot;: return &#x27;user:&#123;&#125;&#x27;.format(id) elif tmp == &quot;item&quot;: return &#x27;item:&#123;&#125;&#x27;.format(id) 自定义路径参数类型1、导入 ：from werkzeug.routing import BaseConverter 2、定义自己类，并继承自 BaseConverter 12class PhoneConverter(BaseConverter): regex = &quot;1[3-9]\\d&#123;9&#125;&quot; 3、注册转换器 1app.url_map.converters[&quot;phone&quot;] = PhoneConverter 4、添加路由 1234@app.route(&#x27;/phone/&lt;phone:phoneNum&gt;&#x27;)def user_info(phoneNum): print(type(phoneNum)) return f&quot;给 &#123;phoneNum&#125; 打个电话&quot; 当路径为 http://127.0.0.1:5000/phone/139111111111 就可以正常匹配了。 自定义转换函数假设传递的路径参数为 /user/zs+18，可以使用如下代码获取： 1234@app.route(&#x27;/user/&lt;info&gt;&#x27;)def user(info): args = info.split(&quot;+&quot;) return f&quot;获取到信息 &#123;args[0]&#125; 和 &#123;args[1]&#125;&quot; 但是代码 args = info.split(&quot;+&quot;) 只是处理字符串，与业务逻辑没什么关系，将代码修改为： 123456789class LiConverter(BaseConverter): def to_python(self, value): return value.split(&#x27;+&#x27;)app.url_map.converters[&#x27;li&#x27;] = LiConverter@app.route(&#x27;/user/&lt;li:info&gt;&#x27;)def user(info): return f&quot;获取到信息 &#123;info[0]&#125; 和 &#123;info[1]&#125;&quot; 此时 user 函数的参数 info，直接接收到的就是路径 /user/zs+18 处理后的结果。 查询参数的使用网址中在 ? 后面的格式为 key=value 的以 &amp; 作为分割的字符串称为查询参数。 为何叫查询参数？因为无论怎么加查询参数（有用的或者没用的）都不会改变所调用的 API 接口，而这些查询参数会传递到 API 接口内部，就像给函数传递参数一样。 1234567891011@app.route(&#x27;/&#x27;)def index(): # 方法1 uname = request.args.get(&quot;uname&quot;) pwd = request.args.get(&quot;pwd&quot;) #方法2 uname = request.values.get(&quot;uname&quot;) pwd = request.values.get(&quot;pwd&quot;) return f&quot;Hello, &#123;uname&#125;, &#123;pwd&#125;&quot; 此时在浏览器中输入 http://127.0.0.1:5000/?uname=zhuning&amp;pwd=1234后台就可以获取到参数 uname 和 pwd。 查询参数是直接暴露在 url 地址中的，用查询参数发起的请求称为 get 请求。 请求体参数当请求的数据需要隐藏或者数据量较大时，就需要使用请求体参数。 请求体参数是隐藏在数据包中的，使用请求体参数发起的请求称为 post 请求。 123456789101112131415# 将这个 url 地址支持 POST 请求@app.route(&#x27;/login&#x27;, methods=[&#x27;POST&#x27;])def login(): #方法1 uname = request.form.get(&#x27;uname&#x27;) pwd = request.form.get(&#x27;pwd&#x27;) #方法2 uname = request.values.get(&#x27;uname&#x27;) pwd = request.values.get(&#x27;pwd&#x27;) if uname == &#x27;zhangsan&#x27; and pwd == &quot;123456&quot;: return &quot;Hello&quot; else: return &quot;Login failed&quot; 注意在浏览器中输入地址无法发送 POST 请求，此时需要使用 PostMan 模拟 POST 请求。 上传文件文件也需要使用 POST 来发送请求，因此需要使用 PostMan 模拟请求。 1234567@app.route(&#x27;/upload&#x27;, methods=[&#x27;POST&#x27;])def upload(): f = request.files.get(&#x27;pic&#x27;) fname = f.filename with open(f&#x27;./images/&#123;fname&#125;&#x27;, &#x27;wb&#x27;) as tf: tf.write(f.read()) return f&#x27;Hello&#x27; 以上代码可以将文件保存到服务器上。 request 其他参数以下代码可以访问到 request 中的常用参数： 12345678910111213@app.route(&#x27;/args&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def args(): url = request.url method = request.method content_type = request.headers.get(&#x27;Content-Type&#x27;) user_agent = request.headers.get(&#x27;User-Agent&#x27;) cookie = request.cookies.get(&#x27;uuid&#x27;) return f&#x27;&#x27;&#x27; url:&#123;url&#125;, method:&#123;method&#125;\tContent-Type:&#123;content_type&#125;\tUser-Agent:&#123;user_agent&#125;\tCookie:&#123;cookie&#125;\t&#x27;&#x27;&#x27; url_for 函数下面的代码中，当路由地址为 /index 时会找到 home 函数，并执行。 12345678@app.route(&#x27;/index&#x27;)def home(): return f&quot;Hello !!&quot;@app.route(&#x27;/show_url&#x27;)def show_url(): url = url_for(&#x27;home&#x27;) return f&#x27;反向查找到的 URL 地址：&#123;url&#125;&#x27; 此时，url_for 函数的作用是通过 home 这个函数名找到与之绑定的路由地址。 下面的代码时查找需要传递参数的路由地址的情况： 12345678@app.route(&#x27;/home/&lt;int:uid&gt;&#x27;)def home(uid): return f&quot;Hello &#123;uid&#125; !!&quot;@app.route(&#x27;/show_url&#x27;)def show_url(): url = url_for(&#x27;home&#x27;, uid=1001) return f&#x27;反向查找到的 URL 地址：&#123;url&#125;&#x27; 如果代码为： 1url = url_for(&#x27;home&#x27;, uid=1001, addr=&#x27;beijing&#x27;) 此时虽然无法匹配合适的路由地址，但是不会报错，且输出将为 反向查找到的 URL 地址：/home/1001?addr=beijing 即将未匹配到的参数当成查询参数。 注意：在定义url时尽量将最后的斜杠加上，即 1@app.route(&#x27;/show_url/&#x27;) 这是因为如果不加，而在浏览器中输入 http://XXXX:5000/show_url 时将访问不到地址。 响应重定向重定向是响应内容的一种。 两种重定向： 永久重定向：http 状态码为 301 ，比如 www.jingdong.com 现在永久重定向到了 www.jd.com 暂时重定向：http 状态码为 302，如果用户没有登录，需要跳转到登陆页面。 以下代码可以在 Flask 中实现重定向 1234567@app.route(&#x27;/login/&#x27;)def login(): return f&quot;Hello World !!&quot;@app.route(&#x27;/info/&#x27;)def info(): return redirect(&#x27;/login/&#x27;, code=301) 上面代码中的 code 是可选的参数，其值可以是 301 和 302，如果不写该参数，默认值为 302。注意 redirect(&#39;/login/&#39;, code=301) 前面的 return，如果没有会报错。 将 redirect 与 url_for 结合，就可以帮助我们在不修改原始代码的情况下，为某个函数绑定一个新的路由地址。 123@app.route(&#x27;/info/&#x27;)def info(): return redirect(url_for(&#x27;login&#x27;)) 响应类型当使用如下代码响应请求时，返回的响应的类型是 HTML 数据 123@app.route(&#x27;/index/&#x27;)def index(): return &quot;你好呀&quot; 以下代码返回 json 数据： 1234567891011#方法1app.config[&#x27;JSON_AS_ASCII&#x27;] = False@app.route(&#x27;/json1/&#x27;)def r_json(): return &#123;&#x27;key&#x27;: &#x27;Python 语言&#x27;&#125;# 方法2from flask import jsonify@app.route(&#x27;/json2/&#x27;)def r_json2(): return jsonify(&#123;&#x27;key&#x27;: &#x27;Python 语言&#x27;&#125;) 其中 app.config[&#39;JSON_AS_ASCII&#39;] = False 的作用是强制将返回的数据按原样输出。 两个方法的区别是，方法1不支持老版本，方法2支持老版本。 以下代码返回 元组 数据： 1234567891011@app.route(&#x27;/tuple1&#x27;)def r_tuple1(): return &#x27;tuple&#x27;, 202@app.route(&#x27;/tuple2&#x27;)def r_tuple2(): return &#x27;tuple&#x27;, &#123;&#x27;itbaizhan&#x27;:&#x27;python&#x27;&#125;@app.route(&#x27;/tuple3&#x27;)def r_tuple3(): return &#x27;tuple&#x27;, 300, &#123;&#x27;itbaizhan&#x27;:&#x27;python&#x27;&#125; 当返回的数据为元组时，其 要么是 (response, status) 要么是 (response, headers) 要么是 (response, status, headers) 三种中的一种，上面代码中就是依次为这三种情况。 如果包含 headers，则响应头中的数据会被 headers 中的数据替换。 headers 部分除了可以是字典外，还可以是列表，效果是一致的，其写法为： return &#39;tuple&#39;, 300, [(&#39;itbaizhan&#39;, &#39;python&#39;)] 自定义响应对象自定义响应指的是自定义响应内容和响应代码。 123@app.route(&#x27;/&#x27;)def index(): return Response(&quot;你好，少年&quot;, status=500, headers=&#123;&#x27;itbaizhan&#x27;: &#x27;python!!!&#x27;&#125;) 其中，你好，少年、status、 headers都是可选的，如果使用 Response() 则表示响应空的内容。 但如果是空的响应最好写成 Response(status=404)。 为了更友好地表示页面未找到，可以使用 Response(&quot;无法找到页面&quot;, status=404)。 自定义响应对象还可以用如下方式创建： 12345678from flask import make_response@app.route(&#x27;/home/&#x27;)def home(): resp = make_response(&quot;这是创建的 Response 对象&quot;) resp.headers[&#x27;itheima&#x27;] = &quot;SQL+Python&quot; resp.status = 666 return resp","tags":["Python","服务器端","Flask","Web 框架"],"categories":["Python","Web 框架","Flask"]},{"title":"CSS(1) - 初识和基本选择器","path":"/2024/05/10/CSS-1-初识和基本选择器/","content":"CSS 的三种引入方式内嵌式 1234567891011121314&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;title&gt;CSS 三种引入方式&lt;/title&gt; &lt;style&gt; p &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;我是一个 p 标签&lt;/p&gt; &lt;p&gt;我也是一个 p 标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 外联式 12345678910&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;title&gt;CSS 三种引入方式&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css基础.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;我是一个 p 标签&lt;/p&gt; &lt;p&gt;我也是一个 p 标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;123p &#123; color: blue;&#125; 行内式 123456789&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;title&gt;CSS 三种引入方式&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p style=&quot;color: green;&quot;&gt;我是一个 p 标签&lt;/p&gt; &lt;p&gt;我也是一个 p 标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 行内式作用范围最小，优先级最大；外联式作用范围最大，优先级最小。优先级顺序为：行内式 &gt; 内嵌式 &gt; 外联式 标签选择器","tags":["前端","CSS"],"categories":["前端","CSS"]},{"title":"hexo-test","path":"/2024/05/09/hexo-test/","content":"引用块Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing 代码块1alert(&#x27;Hello World!&#x27;); 1[rectangle setX: 10 y: 10 width: 20 height: 20]; Array.map1array.map(callback[, thisArg]) _.compactUnderscore.js12_.compact([0, 1, false, 2, &#x27;&#x27;, 3]);=&gt; [1, 2, 3] 彩色代码块 推荐的写法123func test() &#123; // ...&#125; 不推荐的写法123func test() -&gt; () &#123; // ...&#125;"},{"title":"HTML 基础知识","path":"/2024/05/09/HTML-基础内容/","content":"第一章 HTML 初识Web 标准中将网页分为结构，表现和行为三个部分。 其中，结构由 HTML 表示，表现由 CSS 表示，行为由 JavaScript 表示。 HTML 文件本质是一个文本文件，但是其后缀名为 .html。 第二章 HTML 注释和标签HTML 的基本结构 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;网页的标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 网页的主体内容 &lt;/body&gt;&lt;/html&gt; HTML 两种注释 注释是程序员书写的，给自己或者他人看的，用于说明代码功能的文字。注释不会对代码有任何影响。 12345&lt;!-- 单行注释 --&gt;&lt;!-- 多行注释多行注释多行注释 --&gt; HTML 的注释是不能嵌套的，比如如下注释是错误的： 1234&lt;!-- 单行注释 &lt;!-- 单行注释 --&gt; --&gt; HTML 标签有双标签和单标签两种。 双标签：由开始标签和结束标签及其中包裹的内容组成，比如 &lt;strong&gt;内容&lt;/strong&gt;; 单标签：只由一个部分组成，如&lt;br&gt;、&lt;hr&gt;。 HTML 标签的属性都是包含在开始标签中的，每个属性由属性名和属性值组成，如&lt;strong class=&quot;one&quot;&gt;内容&lt;/strong&gt;。 第三章 HTML 常用标签标题标签标题标签有以下 6 种： 123456&lt;h1&gt;1级标题&lt;/h1&gt;&lt;h2&gt;2级标题&lt;/h2&gt;&lt;h3&gt;3级标题&lt;/h3&gt;&lt;h4&gt;4级标题&lt;/h4&gt;&lt;h5&gt;5级标题&lt;/h5&gt;&lt;h6&gt;6级标题&lt;/h6&gt; 这些标签有加粗效果，从 h1 - h6 文字逐渐减小，均独占一行。 段落标签段落标签只有一个 1&lt;p&gt;我是一段文字&lt;/p&gt; 段落标签独占一行，对文字格式没有明显改变，段落之间有间隙。 换行标签、水平线标签换行标签、水平线标签都是单标签，各有一个 12&lt;br&gt; &lt;!-- 换行标签 --&gt;&lt;hr&gt; &lt;!-- 水平线标签 --&gt; 文本格式化标签主要功能是为文字添加加粗、下划线、倾斜、删除等效果。 1234567891011&lt;b&gt;加粗&lt;/b&gt;&lt;u&gt;下划线&lt;/u&gt;&lt;i&gt;倾斜&lt;/i&gt;&lt;s&gt;删除线&lt;/s&gt;&lt;br&gt;&lt;strong&gt;加粗&lt;/strong&gt;&lt;ins&gt;下划线&lt;/ins&gt;&lt;em&gt;倾斜&lt;/em&gt;&lt;del&gt;删除线&lt;/del&gt; 主要功能是突出显示。 其中第二组标签语义更加强烈，因此推荐使用。 图片标签图片标签是最常用的媒体标签，用于展示图片，是单标签。 1234567&lt;img src=&quot;文件路径&quot; alt=&quot;当图片加载失败时，展示的文本，如果加载成功则不显示&quot; title=&quot;当鼠标悬停在图片上时，显示的文本&quot; width=&quot;填写数字，单位像素，但书写时不带单位，如果width和height只设置一个则等比例缩放，如果width和height都设置可能会导致图片变形&quot; height=&quot;800&quot;&gt; 相对路径和绝对路径相对路径用的多。要着重认识。 绝对路径：从盘符开始的路径； 相对路径：从当前文件位置开始查找的路径； ./：表示同级目录； XXX/：表示XXX的下级目录； ../：表示上级目录； 第四章 HTML 其他标签音频标签音频标签是双标签，其中 src 属性是必须的 123456&lt;audio src=&quot;音频文件的路径&quot; controls autoplay loop &gt;&lt;/audio&gt; 其中，controls 属性表示是否显示播放控件； autoplay 属性表示是否自动播放； loop 属性表示是否循环播放； controls、autoplay、loop 属性默认没有属性值 视频标签视频标签是双标签，其属性与音频标签完全一致； 123456&lt;video src=&quot;音频文件的路径&quot; controls autoplay loop &gt;&lt;/video&gt; 超链接标签超链接标签是双标签， 1234&lt;a href=&quot;./目标网页.html&quot; target=&quot;点击超链接标签时，打开网页的方式&quot; &gt;超链接&lt;/a&gt; target 属性的属性值： “_self”：表示在原窗口跳转； “_blank”：表示在新窗口跳转； 超链接标签原始样式为蓝字、下划线； 未点击过时，默认颜色为蓝色；点击过后，为紫色； 1234&lt;a href=&quot;./目标网页.html&quot; target=&quot;点击超链接标签时，打开网页的方式&quot; &gt;超链接&lt;/a&gt; 这样的链接叫做空链接： 作用1：回到网页顶部； 作用2：当跳转的页面还没确定时，用作占位。 第五章 列表与表格列表分无序列表、有序列表、自定义列表，这 3 者在显示上有区别，但实际应用这 3 者的区别主要在语义上。 无序列表语义上表示没有顺序之分 12345&lt;ul&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt;&lt;/ul&gt; 注意：ul 标签中只能包含 li 标签，但 li 标签中可以包含任何标签。 有序别表语义上表示有顺序 12345&lt;ol&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt;&lt;/ol&gt; 注意：ol 标签中只能包含 li 标签，但 li 标签中可以包含任何标签。 自定义列表主要用于表示一个标题、多个项目这样的结构 123456&lt;dl&gt; &lt;dt&gt;帮助中心（列表主题）&lt;/dt&gt; &lt;dd&gt;账号管理（列表内容）&lt;/dd&gt; &lt;dd&gt;购物指南（列表内容）&lt;/dd&gt; &lt;dd&gt;订单操作（列表内容）&lt;/dd&gt;&lt;/dl&gt; 注意：dl 标签中只能包含 dt、dd 标签，但 dt、dd 标签中可以包含任何标签。 表格标签1234567891011&lt;table border=&quot;1&quot; width=&quot;100&quot; height=&quot;100&quot;&gt; &lt;caption&gt;表格题目&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;标题1&lt;/th&gt; &lt;th&gt;标题2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;内容1&lt;/td&gt; &lt;td&gt;内容2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 其中， caption 应该放在 table 标签的一开始； table 标签中可以包含 tr 标签； tr 标签中可以包含 th、td 标签： th 标签（table head）用于表头单元格的内容； td 标签用于表格内容单元格。 border 属性表示边框的宽度，width、height 用于设置高度和宽度， 这三个属性可以用于 table、th、tr、td 标签，用于不同标签时其作用范围不同。 除了上述内容外，表格还有 3 个结构标签，thead、tbody、tfoot，这 3 个标签用于表示表格各部分的语义特征，用法如下： 1234567891011121314&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;标题1&lt;/th&gt; &lt;th&gt;标题2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;内容1&lt;/td&gt; &lt;td&gt;内容2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; rowspan、colspan 属性用于合并单元格，这两个属性应写在td 标签中 注意：1、rowspan 是在垂直方向上合并，colspan 是在水平方向上合并； ​ 2、rowspan、colspan 不能跨结构标签，即不能跨 thead、tbody、tfoot 这 3 个标签。 第六章 表单标签input 系列标签input 标签最主要的是 type 属性，其属性值如下： 12345678910111213141516&lt;!-- 1、文本框：type=&quot;text&quot; --&gt;昵称: &lt;input type=&quot;text&quot; value=&quot;123123&quot;&gt; &lt;br&gt;&lt;!-- 2、密码框：type=&quot;password&quot; --&gt;密码: &lt;input type=&quot;password&quot; value=&quot;123123&quot;&gt; &lt;br&gt;&lt;!-- 3、单选框：type=&quot;radio&quot; 多个单选框只能有一个被选中 --&gt;性别：&lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;女 &lt;br&gt;&lt;!-- 4、复选框：type=&quot;checkbox&quot; --&gt;爱好: &lt;input type=&quot;checkbox&quot;&gt;敲代码&lt;input type=&quot;checkbox&quot;&gt;玩游戏 &lt;br&gt;&lt;!-- 5、文件选择框：type=&quot;file&quot; --&gt;&lt;input type=&quot;file&quot;&gt; &lt;br&gt;&lt;!-- 6、按钮：按钮的属性值有 3 个，分别为：submit、reset、button --&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;普通按钮&quot;&gt; type&#x3D;”text” 的 input 标签为文本框： 属性 placeholder&#x3D;”XXX” 用于显示提示内容。 type&#x3D;”password” 的 input 标签为密码框： 属性 placeholder&#x3D;”XXX” 用于显示提示内容。 type&#x3D;”radio” 的 input 标签为单选框： 属性 name&#x3D;”XXX” 表示，name 相同的多个单选框为一组，一组单选框中只有 1 个单选框会被选中； checked 属性默认没有属性值，其表示某个单选框是否为选中状态，同一组单选框中的多个单选框如果都设置了 checked 则最后一个单选框被选中。 type&#x3D;”checkbox” 的 input 标签为复选框： checked 属性默认没有属性值，其表示某个复选框是否为选中状态。 type&#x3D;”file” 的 input 标签为文件选择框： multiple 属性默认没有属性值，表示是否可以选择多个文件。 一般来说，所有 input 标签都应该包含在 标签中。 字符实体空格合并：在 HTML 代码中连续出现多个空格、换行、缩进时，在显示时都会被压缩成一个空格； 使用字符实体可解决该问题 常见的字符实体有： 第七章 作业制作下面的表格： 制作下面的页面：","tags":["HTML","前端"],"categories":["前端","HTML"]}]