[{"title":"Flask-2-Jinja2模板","path":"/2024/05/21/Flask-2-Jinja2模板/","content":"模板基础为什么要模板原则上来讲使用如下代码是可以写出任意网站的 1234567891011from flask import Flaskapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index(): return &#x27;&lt;h1&gt;这是标题&lt;/h1&gt;&lt;p&gt;这是内容&lt;/p&gt;&#x27;if __name__ == &#x27;__main__&#x27;: app.config.from_pyfile(&#x27;settings.py&#x27;) app.run() 但这显然不是好的办法，因此需要模板。 模板的简单使用Flask 种使用的是 Jinja2 模板。 使用模板的步骤： 创建名为 templates 的文件夹； 在该文件夹中创建名为 index.html 的文件，在其中编写如下内容； 123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;模板的使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, 模板的使用&lt;/h1&gt; &lt;p&gt;这个是模板的使用案例！！&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 编写如下代码，使用模板： 123456from flask import render_template@app.route(&#x27;/&#x27;)def index(): # 模板默认的文件夹是 template return render_template(&#x27;index19.html&#x27;) 模板的默认文件夹是 templates，如果要修改，使用如下代码： 1app = Flask(__name__, template_folder=&#x27;template&#x27;) 模板传参使用如下代码向模板传递参数： 1return render_template(&#x27;index19.html&#x27;, info=&#x27;Flask 模板&#x27;) 在模板中使用如下语法接收模板： 1&lt;p&gt;接收到的参数：&#123;&#123; info &#125;&#125;&lt;/p&gt; 一般在需要传递的参数比较多的情况下，会使用以下做法： 123456789@app.route(&#x27;/&#x27;)def index(): # 模板默认的文件夹是 template context = &#123; &#x27;uname&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 18, &#x27;height&#x27;: 180 &#125; return render_template(&#x27;index19.html&#x27;, **context) 模板中的 url_for 函数url_for 函数可以通过函数名查找到与之相绑定的路径。 1234567891011@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;index19.html&#x27;)@app.route(&#x27;/home/&#x27;)def home(): return &quot;Home!!&quot;@app.route(&#x27;/home1/&lt;int:id&gt;/&#x27;)def home1(id): return &quot;Home!!&quot; 1234567891011&lt;html&gt; &lt;head&gt; &lt;title&gt;模板的使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;url_for 函数&lt;/h1&gt; &lt;p&gt;&#123;&#123; url_for(&#x27;home&#x27;)&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; url_for(&#x27;home1&#x27;, id=1101)&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; url_for(&#x27;home1&#x27;, id=1101, addr=&#x27;bj&#x27;)&#125;&#125;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 此时在页面中显示的内容就是 home、home1 函数对应的 url 路径。 有了 url_for 函数，我们可以做到： 在页面上动态生成链接； 如果与 home 函数绑定的 url 由 /home/ 改为 /home1/ 了，仍然可以使用 url_for(&#39;home&#39;) 来代替新的地址。 过滤器过滤器介绍比如将 10.1 改为 10，将 sxt 改为 SXT 等功能，都可以用过滤器实现。 123@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;index19.html&#x27;, param=10.5) 12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;模板的使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;过滤器的使用&lt;/h1&gt; &lt;p&gt;过滤前的数据是：&#123;&#123; param &#125;&#125;&lt;/p&gt; &lt;p&gt;过滤后的数据是：&#123;&#123; param | int &#125;&#125;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 此时网页中的第二行内容就是经过过滤器处理的。 注意：过滤器是在模板中使用的，其格式为 &#123;&#123; data | filter &#125;&#125;。 default 过滤器当代码为： 123@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;index19.html&#x27;, nickname=&quot;jjk&quot;) 12&lt;p&gt;过滤前的昵称是：&#123;&#123; nickname &#125;&#125;&lt;/p&gt;&lt;p&gt;过滤后的昵称是：&#123;&#123; nickname | default(&#x27;用户1&#x27;) &#125;&#125;&lt;/p&gt; 因为在处理函数中向模板传递了 nickname 参数，因此 default 就不起作用了，其显示效果为： 而将代码中的 nickname 参数去掉后： 1return render_template(&#x27;index19.html&#x27;) 其显示效果为： 注意：如果在 render_template 函数中给出了 nickname 参数，但其值为 None、[]、””、{} 等，默认情况下 default 不会识别，其显示效果如下： 如果使其正常显示，为 default 过滤器添加参数，如下： 1&lt;p&gt;过滤后的昵称是：&#123;&#123; nickname | default(&#x27;用户1&#x27;, boolean=True) &#125;&#125;&lt;/p&gt; 现在的显示为： 下面的代码也可以实现与 default 过滤器类似的效果： 1&lt;p&gt;过滤后的昵称是：&#123;&#123; nickname or &#x27;用户2&#x27; &#125;&#125;&lt;/p&gt; 转义字符过滤器在 HTML 中 &lt;、&gt;、空格、\\t 等都有特殊的含义或者特殊的显示效果。 1234@app.route(&#x27;/&#x27;)def index(): info = &#x27;&lt;script&gt;alert(&quot;Hello!!&quot;)&lt;/script&gt;&#x27; return render_template(&#x27;index19.html&#x27;, info=info) 123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;模板的使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;转义字符过滤器的使用&lt;/h1&gt; &lt;p&gt;转义前的数据是：&#123;&#123; info &#125;&#125;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 根据直觉，HTML 中会将 info 字符串的数据原样输入，而不会将其当成 js 代码执行 ，事实确实也是如此： 如果要让 info 中的字符串被当作 js 代码来执行，应该使用 safe 过滤器 1&lt;p&gt;转义后的数据是：&#123;&#123; info | safe &#125;&#125;&lt;/p&gt; 为了更精细的控制转义与不转义，可以使用 autoescape 和 escape 配合 来控制 12345678910111213&lt;body&gt; &lt;h1&gt;转义字符过滤器的使用&lt;/h1&gt; &#123;% autoescape false %&#125; 第一行：&#123;&#123; info &#125;&#125; &lt;br&gt; 第二行：&#123;&#123; info | escape &#125;&#125; &#123;% endautoescape %&#125; &#123;% autoescape true %&#125; &lt;br&gt; 第三行：&#123;&#123; info &#125;&#125; &#123;% endautoescape %&#125;&lt;/body&gt; autoescape 设定了“大环境”，autoescape false 代表大环境是不转义，autoescape Trueue 代表大环境是转义，而 escape 代表无论“大环境”是什么，都强制转义。 此时第一行的 info 会被当成 js 代码执行，也就是“大环境”不转义； ​\t第二行的 info 会被当成字符串显示，也就是“大环境”不转义，但 escape 强制转义； ​\t第三行的 info 会被当成字符串显示，也就是“大环境”转义了； 其他过滤器以下是常见的过滤器： 123456789101112&lt;h1&gt;其他过滤器的使用&lt;/h1&gt;&lt;p&gt;绝对值：&#123;&#123; -6 | abs &#125;&#125;&lt;/p&gt;&lt;p&gt;浮点数：&#123;&#123; -6 | float &#125;&#125;&lt;/p&gt;&lt;p&gt;字符串：&#123;&#123; -6 | string &#125;&#125;&lt;/p&gt;&lt;br&gt;&lt;p&gt;格式化：&#123;&#123; &#x27;%s--%s&#x27; | format(&#x27;我&#x27;, &#x27;你&#x27;) &#125;&#125;&lt;/p&gt;&lt;p&gt;字符串长度：&#123;&#123; &#x27;我是九，你是三，除了你，还是你&#x27; | length &#125;&#125;&lt;/p&gt;&lt;p&gt;字符串最后一个字符：&#123;&#123; &#x27;我是九，你是三，除了你，还是你&#x27; | last &#125;&#125;&lt;/p&gt;&lt;p&gt;字符串第一个字符：&#123;&#123; &#x27;我是九，你是三，除了你，还是你&#x27; | first &#125;&#125;&lt;/p&gt;&lt;!-- wordcount 统计的是有多少单词（以空格、逗号、句号分割的认为是一个单词） --&gt;&lt;p&gt;统计次数：&#123;&#123; &#x27;我是九，你是三，除了你，还是你&#x27; | wordcount &#125;&#125;&lt;/p&gt;&lt;p&gt;统计次数：&#123;&#123; &#x27;我是九，你是三，除了你，还是你&#x27; | replace(&#x27;你&#x27;, &#x27;you&#x27;) &#125;&#125;&lt;/p&gt; 自定义过滤器过滤器本质上就是一个函数，变量的值将作为函数的第一个参数，传递给函数。 自定义名为 cut 的过滤器： 12345678@app.template_filter(&#x27;cut&#x27;)def cut(value): value = value.replace(&#x27;我是九，你是三，除了你，还是你&#x27;, &#x27;你不用多好，我喜欢就好&#x27;) return value@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;index19.html&#x27;, info=&#x27;我是九，你是三，除了你，还是你&#x27;) 123&lt;h1&gt;自定义过滤器的使用&lt;/h1&gt;&lt;p&gt;过滤前的值：&#123;&#123; info &#125;&#125;&lt;/p&gt;&lt;p&gt;过滤后的值：&#123;&#123; info | cut &#125;&#125;&lt;/p&gt; 此时显示效果为： 自定义时间过滤器时间过滤器也是过滤器的一种，只是它是专门用来处理时间的，以下代码定义了一个时间过滤器： 1234567891011121314151617181920212223242526272829303132333435from flask import Flask, render_templatefrom datetime import datetime@app.template_filter(&#x27;handler_time&#x27;)def handler_time(time): &quot;&quot;&quot; time距离现在的时间间隔 1. 如果时间间隔小于1分钟以内，那么就显示“刚刚” 2. 如果是大于1分钟小于1小时，那么就显示“xx分钟前” 3. 如果是大于1小时小于24小时，那么就显示“xx小时前” 4. 如果是大于24小时小于30天以内，那么就显示“xx天前” 5. 否则就是显示具体的时间 2030/10/20 16:15 &quot;&quot;&quot; now = datetime.now() # 相差的时间，以秒为单位 temp_stamp = (now - time).total_seconds() # 格式化以秒为单位的时间 if temp_stamp &lt; 60: return &#x27;1分钟之前&#x27; elif temp_stamp &gt;= 60 and temp_stamp &lt;= 60 * 60: return &#x27;1小时之前&#x27; elif temp_stamp &gt;= 60*60 and temp_stamp &lt;= 24*60*60: hour = int(temp_stamp/(60*60)) return f&#x27;&#123;hour&#125;小时之前&#x27; elif temp_stamp &gt;= 60*60*24 and temp_stamp &lt;= 24*60*60*30: day = int(temp_stamp / (60 * 60 * 24)) return f&#x27;&#123;day&#125;天之前&#x27; else: return &#x27;很久以前&#x27;@app.route(&#x27;/&#x27;)def index(): tmp_time = datetime(2024, 5, 24, 23, 54) return render_template(&#x27;index19.html&#x27;, tmp_time=tmp_time) 12&lt;h1&gt;自定义时间过滤器的使用&lt;/h1&gt;&lt;p&gt;过滤后的时间：&#123;&#123; tmp_time | handler_time &#125;&#125;&lt;/p&gt; 显示效果为： 结构语句理论上来说，模板中的选择、判断机构语句可以实现 Python 中的选择、判断机构语句能实现的一切功能，但是一般而言，模板的选择、判断机构语句只应实现相对简单的功能。 至于哪些功能放在模板的选择、判断机构语句中，哪些放在 Python 的选择、判断机构语句中，应该根据实际情况进行取舍。 选择结构1234@app.route(&#x27;/&#x27;)def index(): uname = &#x27;bz&#x27; return render_template(&#x27;index19.html&#x27;, uname=uname) 12345678910&lt;body&gt; &lt;h1&gt;流程控制语句-选择结构&lt;/h1&gt; &#123;% if uname == &#x27;sxt&#x27; %&#125; &lt;p&gt;尚学堂&lt;/p&gt; &#123;% elif uname == &#x27;bz&#x27; %&#125; &lt;p&gt;百战程序员&lt;/p&gt; &#123;% else %&#125; &lt;p&gt;其他&lt;/p&gt; &#123;% endif %&#125;&lt;/body&gt; 显示效果如下： 循环结构数组、字典的循环12345@app.route(&#x27;/&#x27;)def index(): items = [&#x27;Python&#x27;, &#x27;HTML&#x27;, &#x27;CSS&#x27;, &#x27;JavaScript&#x27;, &#x27;SQL&#x27;, &#x27;Lua&#x27;] persons = &#123;&#x27;uname&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 18, &#x27;height&#x27;: 180, &#x27;nick&#x27;: &#x27;战争狂徒&#x27;&#125; return render_template(&#x27;index19.html&#x27;, items=items, persons=persons) 12345678&lt;h1&gt;流程控制语句-循环结构&lt;/h1&gt;&#123;% for item in items %&#125; &lt;p&gt;&#123;&#123; item &#125;&#125;&lt;/p&gt;&#123;% endfor%&#125;&lt;hr&gt;&#123;% for key in persons.keys() %&#125; &lt;p&gt;&#123;&#123; key &#125;&#125;:&#123;&#123; persons[key] &#125;&#125;&lt;/p&gt;&#123;% endfor%&#125; 显示效果如下： 循环变量jinja2 模板中还提供了如下的循环变量，用于获取循环的状态 123&#123;% for item in items %&#125; &lt;p&gt;&#123;&#123; loop.length &#125;&#125; -- &#123;&#123; item &#125;&#125; -- &#123;&#123; loop.index &#125;&#125; -- &#123;&#123; loop.index0 &#125;&#125; -- &#123;&#123; loop.last &#125;&#125; -- &#123;&#123; loop.first &#125;&#125;&lt;/p&gt;&#123;% endfor%&#125; 显示效果如下： 变量 描述 loop.index 当前迭代的索引（从1开始） loop.index0 当前迭代的索引（从0开始） loop.first 是否是第一次迭代，返回True或False loop.last 是否是最后一次迭代，返回True或False loop.length 序列的长度 循环中使用过滤器将过滤器加在需要循环的变量后面： 123&#123;% for item in items | reverse %&#125; &lt;p&gt;&#123;&#123; item &#125;&#125;&lt;/p&gt;&#123;% endfor%&#125; 效果如下： 特别注意1：jinja2 中的 for 循环没有 break、continue 语句。 特别注意2：jinja2 中的 for 循环有 else 语句，作用是需要循环的变量可以转化为 False 时，执行 else 中的代码，如 1234@app.route(&#x27;/&#x27;)def index(): items = [] return render_template(&#x27;index19.html&#x27;, items=items) 123456&lt;h1&gt;流程控制语句-循环结构&lt;/h1&gt;&#123;% for item in items %&#125; &lt;p&gt;&#123;&#123; item &#125;&#125;&lt;/p&gt;&#123;% else %&#125; &lt;p&gt;没有任何内容&lt;/p&gt;&#123;% endfor%&#125; 显示效果为： 宏模板的宏类似于函数，但宏可以接收参数，但是没有返回值。 基本使用12345678910111213141516171819202122232425262728293031&#123;% macro inp(type, name=&#x27;&#x27;, value=&#x27;&#x27;) %&#125; &lt;input type=&#123;&#123; type &#125;&#125; name=&#123;&#123; name &#125;&#125; value=&#123;&#123; value &#125;&#125;&gt;&#123;% endmacro %&#125;&lt;body&gt; &lt;h1&gt;不使用宏&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;&quot; value=&quot;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码：&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;&quot; value=&quot;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;hr&gt; &lt;h1&gt;使用宏&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt;&lt;td&gt;&#123;&#123; inp(&#x27;text&#x27;, &#x27;uname&#x27;) &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码：&lt;/td&gt;&lt;td&gt;&#123;&#123; inp(&#x27;password&#x27;, &#x27;pwd&#x27;) &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&#123;&#123; inp(&#x27;submit&#x27;, value=&#x27;登录&#x27;) &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt; 上下两种代码的显示效果是一致的。 注意代码中，在宏里面使用默认参数的方法。 宏的引入如果一个宏可能在多个模板中使用，此时应该将宏放在独立的文件中，并在需要使用时引入。 在模板文件夹 template 中创建名为 macros 的文件夹，在文件夹中创建名为 common.html 的宏； 在 macro.html 定义宏，如： 123&#123;% macro inp(type, name=&#x27;&#x27;, value=&#x27;&#x27;) %&#125; &lt;input type=&#123;&#123; type &#125;&#125; name=&#123;&#123; name &#125;&#125; value=&#123;&#123; value &#125;&#125;&gt;&#123;% endmacro %&#125; 在需要使用前引入这个宏。 引入宏的方法有 2 种 &#123;% import 'macros/common.html' as mc %&#125; 1232. ``` &#123;% from &#x27;macros/common.html&#x27; import inp %&#125; 完整代码如下： 1234@app.route(&#x27;/&#x27;)def index(): nick = &#x27;好人&#x27; return render_template(&#x27;index19.html&#x27;, nick=nick) 1234567891011121314151617181920212223242526272829303132333435363738394041&#123;% import &#x27;macros/common.html&#x27; as mc %&#125;&#123;% from &#x27;macros/common.html&#x27; import inp %&#125;&lt;body&gt; &lt;h1&gt;不使用宏&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;&quot; value=&quot;&#123;&#123; nick &#125;&#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码：&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;&quot; value=&quot;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;h1&gt;使用宏(import)&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt;&lt;td&gt;&#123;&#123; mc.inp(name=&#x27;uname&#x27;, value=nick) &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码：&lt;/td&gt;&lt;td&gt;&#123;&#123; mc.inp(&#x27;password&#x27;, &#x27;pwd&#x27;) &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&#123;&#123; mc.inp(&#x27;submit&#x27;, value=&#x27;登录&#x27;) &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;h1&gt;使用宏(from...import)&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt;&lt;td&gt;&#123;&#123; inp(name=&#x27;uname&#x27;, value=nick) &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码：&lt;/td&gt;&lt;td&gt;&#123;&#123; inp(&#x27;password&#x27;, &#x27;pwd&#x27;) &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&#123;&#123; inp(&#x27;submit&#x27;, value=&#x27;登录&#x27;) &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt; 注意： 1&lt;td&gt;用户名：&lt;/td&gt;&lt;td&gt;&#123;&#123; inp(name=&#x27;uname&#x27;, value=nick) &#125;&#125;&lt;/td&gt; 中的 value=nick 的 nick 为 Python 中传递过来的变量，但是因为它的外层已经有了 &#123;&#123; ... &#125;&#125; 的结构，所以不需要写为 &#123;&#123; nick &#125;&#125; 了。 在宏中使用变量如果想要在宏中直接使用 Python 中的变量，即： 1234@app.route(&#x27;/&#x27;)def index(): nick = &#x27;好人&#x27; return render_template(&#x27;index19.html&#x27;, nick=nick) 123&#123;% macro inp(type=&#x27;text&#x27;, name=&#x27;&#x27;, value=nick) %&#125; &lt;input type=&#123;&#123; type &#125;&#125; name=&#123;&#123; name &#125;&#125; value=&#123;&#123; value &#125;&#125;&gt;&#123;% endmacro %&#125; 1234567891011121314151617181920212223242526272829&#123;% import &#x27;macros/common.html&#x27; as mc %&#125;&#123;% from &#x27;macros/common.html&#x27; import inp %&#125;&lt;body&gt; &lt;h1&gt;使用宏(import)&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt;&lt;td&gt;&#123;&#123; mc.inp(name=&#x27;uname&#x27;) &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码：&lt;/td&gt;&lt;td&gt;&#123;&#123; mc.inp(&#x27;password&#x27;, &#x27;pwd&#x27;, &#x27;&#x27;) &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&#123;&#123; mc.inp(&#x27;submit&#x27;, value=&#x27;登录&#x27;) &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;h1&gt;使用宏(from...import)&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt;&lt;td&gt;&#123;&#123; inp(name=&#x27;uname&#x27;) &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码：&lt;/td&gt;&lt;td&gt;&#123;&#123; inp(&#x27;password&#x27;, &#x27;pwd&#x27;, &#x27;&#x27;) &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&#123;&#123; inp(&#x27;submit&#x27;, value=&#x27;登录&#x27;) &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt; 此时显示效果为： 显然，宏没有接收到 Python 中传递的变量，该怎么办？ 此时需要在引入模板时加入 with context，即： 12&#123;% import &#x27;macros/common.html&#x27; as mc with context %&#125;&#123;% from &#x27;macros/common.html&#x27; import inp with context %&#125; 此时显示效果为： include 的使用一个网页通常由”头部“、”内容“、”底部“三个部分组成，我们可以使用如下代码实现： 123&lt;nav&gt;头部信息&lt;/nav&gt;&lt;main&gt;主要内容&lt;/main&gt;&lt;footer&gt;底部信息&lt;/footer&gt; 但是”头部“、”底部“可能会在多个页面中复用，此时需要使用 include 导入页面。 创建名为 common 的文件夹； 在 common 文件夹中创建名为 header.html、footer.html 两个文件，内容分别为 1&lt;nav&gt;头部信息&lt;/nav&gt; 1&lt;footer&gt;底部信息&lt;/footer&gt; 导入这两个文件 1234&lt;h1&gt;include 的使用&lt;/h1&gt;&#123;% include &#x27;common/header.html&#x27; %&#125;&lt;nav&gt;主要内容&lt;/nav&gt;&#123;% include &#x27;common/footer.html&#x27; %&#125; 此时显示效果与将代码写在一个文件中一致： 用 include 标签导入的内容中使用父模板中的变量，直接使用即可，不需要使用 with context： 123@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;index19.html&#x27;, uname=&quot;尚学堂&quot;) 12&lt;footer&gt;底部信息&lt;/footer&gt;&#123;&#123; uname &#125;&#125; 显示效果为： set 和 with 的使用作用是在模板中定义变量。 1234567&lt;h1&gt;set 和 with 的使用&lt;/h1&gt;&#123;% set uname = &#x27;sxt&#x27; %&#125;&lt;p&gt;用户名：&#123;&#123; uname &#125;&#125;&lt;/p&gt;&#123;% with nick = &#x27;超人&#x27; %&#125;&lt;p&gt;昵称：&#123;&#123; nick &#125;&#125;&lt;/p&gt;&#123;% endwith %&#125; 显示效果为： 显然，set 语句无法设置作用范围，可以认为是全局的； with 语句是与 endwith 成对出现的，可以设置作用范围，是局部的； 通常使用 with 语句更加频繁。 set 和 with 也经常结合使用： 12345&lt;h1&gt;set 和 with 的使用&lt;/h1&gt;&#123;% with %&#125;&#123;% set age=18 %&#125;&lt;p&gt;年龄：&#123;&#123; age &#125;&#125;&lt;/p&gt;&#123;% endwith %&#125; 此时 set 语句也有了作用范围。 引入静态资源静态资源包括但不限于“图片”、“CSS”、“JS”。 如果在 jinja2 模板中这样引入静态资源： 12&lt;h1&gt;静态资源的使用&lt;/h1&gt;&lt;img src=&quot;images/1.jpg&quot;&gt; 是没有办法正常显示的，即使该图片确实存在且路径也没有问题。 应当按照如下步骤，引入静态文件： 创建名为 static 的文件夹，将静态文件放入该文件夹； 将 img 标签中的路径改为 /static/1.jpg 显示效果为： 以上是一种方法，更加通用的方法是使用如下代码： 12&lt;h1&gt;静态资源的使用&lt;/h1&gt;&lt;img src=&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;1.jpg&#x27;) &#125;&#125;&quot;&gt; 显示效果是一致的。 如果要引入 js、css 代码，也应该使用这样的方法。 特别注意：如果图片位于 static/images/1.jpg，如果使用代码： 1&lt;img src=&quot;&#123;&#123; url_for(&#x27;static/images&#x27;, filename=&#x27;1.jpg&#x27;) &#125;&#125;&quot;&gt; 是不能正确导入的，正确的代码是： 1&lt;img src=&quot;&#123;&#123; url_for(&#x27;static&#x27;, filename=&#x27;images/1.jpg&#x27;) &#125;&#125;&quot;&gt; 如果向修改默认的静态文件目录，应该： 1app = Flask(__name__, static_folder=&#x27;XXX&#x27;) 模板继承模板的继承模板继承与 include 导入的关系如下图所示： 左边的是 include 的逻辑图，右边是模板继承的逻辑图。 在 templates 下创建名为 base.html 的文件，作为父模板，其结构为： 12&#123;% block block的名字 %&#125;&#123;% endblock %&#125; 在 templates 下创建名为 index.html 的文件，作为子模板，其结构为 123&#123;% block block的名字 %&#125;子模板中的代码&#123;% endblock %&#125; 注意：父模板与子模板中的 block的名字 一致的两个部分才能实现配对。 具体例子如下，base.html 代码为： 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;title&gt;模板的使用&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;模板继承&lt;/h1&gt; &lt;h1&gt;头部信息&lt;/h1&gt; &#123;% block content %&#125; 这个地方是内容主体 &#123;% endblock %&#125; &lt;h1&gt;底部信息&lt;/h1&gt; &#123;% block footer %&#125; &#123;% endblock %&#125; &lt;/body&gt;&lt;/html&gt; index.html 代码为： 123456789&#123;% extends &#x27;base.html&#x27; %&#125;&#123;% block content %&#125; &lt;P&gt;这是子模板的内容&lt;/P&gt;&#123;% endblock %&#125;&#123;% block footer %&#125; &lt;P&gt;这是底部子模板的内容&lt;/P&gt;&#123;% endblock %&#125; 显示效果为： 可见，父模板中的 content 部分的内容已经被子模板中对应部分的内容取代了。 如果子模板想要在保留父模板内容的前提下添加内容，可以使用 super 函数： 1234&#123;% block content %&#125; &#123;&#123; super() &#125;&#125; &lt;P&gt;这是子模板的内容&lt;/P&gt;&#123;% endblock %&#125; 显示效果为： 如果子模板想要使用子模板中其他部分的内容，可以使用 self.XXX 函数：","tags":["Python","服务器端","Flask","Web 框架"],"categories":["Python","Web 框架","Flask"]},{"title":"Flask(1)-视图基础及URL","path":"/2024/05/12/Flask-1-视图基础及URL/","content":"Flask 入门Flask 可用于网站、公众号、APP、小程序的后端部分开发。 Flask 路由部分使用 Werkzeug 模块，模板引擎使用 Jinja2。 除此以外，其他常用的插件还有： 名称 介绍 Flask-SQLalchemy 操作数据库 Flask-script 插入脚本 Flask-migrate 管理迁移数据库 Flask-Session Session存储方式指定 Flask-WTF 表单 Flask-Mail 邮件 Flask-Bable 提供国际化和本地化支持，翻译 Flask-Login 认证用户状态 Flask-OpenID 认证 Flask-RESTful 开发REST API的工具 Flask-Bootstrap 集成前端Twitter Bootstrap框架 Flask-Moment 本地化日期和时间 Flask-Admin 简单而可扩展的管理接口的框架 中文文档 英文文档 Flask 的第一个应用地址安装 FLask： 1pip install flask 第一个Flask程序: 12345678910111213141516# 引入 Flask 对象，用于创建 web 应用对象from flask import Flask# 创建对象app = Flask(__name__)# 配置路由@app.route(&#x27;/index&#x27;)def index(): return &#x27;尚学堂&#x27;if __name__ == &#x27;__main__&#x27;: # 启动 web 应用（默认端口为 5000） app.run() # 将端口改为 8000 # app.run(port=8000) Flask 运行方式如果需要使得其他计算机可以访问 Flask 启动的 web 应用，应将 Flask 启动 web 应用的代码改为： 1app.run(host=&quot;0.0.0.0&quot;, port=8000) 此时运行程序会给出两个可以使用的地址： 还可以使用命令行启动 Flask： 1234# 需要在系统中设置名为 FLASK_APP 的环境变量，用于指明启动哪个 Flask 服务$ export FLASK_APP=helloworld$ flask run -h 0.0.0.0 -p 8000* Running on http://127.0.0.1:5000/ DEBUG 模式当程序中出现错误，如： 123456@app.route(&#x27;/index&#x27;)def index(): a = 0 b = 1 c = b/a return &#x27;尚学堂&#x27; 此时浏览器显示为： 此时需要开启 DEBUG 模式，方法为： 1app.run(debug=True) 此时，网页上就会显示出错误： 除此以外，DEBUG 模式还可以实现 ”修改代码后，网页可以刷新看效果“ 的效果。 除了以上打开 DEBUG 模式的方法，还可以： 12app.debug = Trueapp.run() Flask 参数的加载以 DEBUG 模式为例，来看看设置 Flask 参数的几种方式： 第1种、运行时传递参数 1app.run(debug = True) 第2种、通过设置 app 的属性 12app.debug = Trueapp.run() 第3种、修改配置参数 123app.config.update(DEBUG=True)# app.config[&#x27;DEBUG&#x27;] = Trueapp.run() 第4种、通过 mapping 加载 12app.config.from_mapping(&#123;&#x27;DEBUG&#x27;:True&#125;)app.run() 第5种、通过配置对象设置config 1234class Config:\tDEBUG = Trueapp.config.from_object(config)app.run() 第6种、将配置写在独立文件中 config.py1DEBUG = True config.json1&#123;&quot;DEBUG&quot;:&quot;True&quot;&#125; app.py12app.config.from_pyfile(&#x27;config.py&#x27;)app.config.from_json(&#x27;config.json&#x27;) 第7种、通过环境变量设置 添加环境变量 DEBUG = True 1app.config.from_envvar(&#x27;DEBUG&#x27;) 推荐使用第六种方式中的 config.py 配置文件 Flask 动态路由URL 路径参数比如，请求的地址为 /users/10011，其中 10011是用户的编号，此时想要获取这个编号，并进一步处理： 12345@app.route(&#x27;/users/&lt;user_id&gt;&#x27;)def user_info(user_id): print(type(user_id)) # 获取 user_id 后，到数据库进行查询，并形成结果，等待输出 return &#x27;hello user&#123;&#125;&#x27;.format(user_id) 此时地址中的用户编号就赋值给了 user_id 这个变量。 路径参数的类型默认 Flask 将路径参数当作字符串处理。 要改变路径参数，用如下方法： 1234@app.route(&#x27;/users/&lt;int:user_id&gt;&#x27;)def user_info(user_id): print(type(user_id)) return &#x27;hello user&#123;&#125;&#x27;.format(user_id) 除了 int 以外，还有 string、float、path、uuid、any 可以用于路径参数。 如果输入的参数无法匹配路径参数的类型，将作为没有匹配到路径，也就是 not found 错误。比如：路由为 @app.route(&#39;/users/&lt;int:user_id&gt;&#39;)，而输入的路径为 http://127.0.0.1:5000/users/111.11，则认为没有对应的路由。 path 类型 再如：路由为 @app.route(&#39;/path/&lt;string:path_id&gt;&#39;)，而输入的路径为 http://127.0.0.1:5000/path/a/b/c，想法是 path_id 被赋值为 a/b/c，但结果是 Not Found。此时就需要类型 path 的路径参数了。 将代码改为 1234@app.route(&#x27;/path/&lt;path:path_id&gt;&#x27;)def user_info(path_id): print(type(path_id)) return &#x27;path:&#123;&#125;&#x27;.format(path_id) 输入的路径为 http://127.0.0.1:5000/path/a/b/c，此时 path_id 被赋值为 a/b/c了。 UUID 类型 如果代码为： 1234@app.route(&#x27;/uuid/&lt;uuid:uuid_id&gt;&#x27;)def user_info(uuid_id): print(type(uuid_id)) return &#x27;path:&#123;&#125;&#x27;.format(uuid_id) 此时路径参数的类型是 UUID。 注意：UUID 是由固定格式的，比如当前路径为 http://127.0.0.1:5000/path/123就无法正确匹配，会 not found。 如果路径为 http://127.0.0.1:5000/uuid/d22ad6c3-bb64-4b9c-b1c0-5b961f0d4bbb 则匹配到的 UUID 为 d22ad6c3-bb64-4b9c-b1c0-5b961f0d4bbb any 类型 假设有多个路径为 /user/id、/item/id、/article/id，我们发现其结构类似，此时可以使用 any 类型来处理，代码如下： 123456@app.route(&#x27;/&lt;any(user, item):tmp&gt;/&lt;int:id&gt;&#x27;)def user_info(tmp, id): if tmp == &quot;user&quot;: return &#x27;user:&#123;&#125;&#x27;.format(id) elif tmp == &quot;item&quot;: return &#x27;item:&#123;&#125;&#x27;.format(id) 自定义路径参数类型1、导入 ：from werkzeug.routing import BaseConverter 2、定义自己类，并继承自 BaseConverter 12class PhoneConverter(BaseConverter): regex = &quot;1[3-9]\\d&#123;9&#125;&quot; 3、注册转换器 1app.url_map.converters[&quot;phone&quot;] = PhoneConverter 4、添加路由 1234@app.route(&#x27;/phone/&lt;phone:phoneNum&gt;&#x27;)def user_info(phoneNum): print(type(phoneNum)) return f&quot;给 &#123;phoneNum&#125; 打个电话&quot; 当路径为 http://127.0.0.1:5000/phone/139111111111 就可以正常匹配了。 自定义转换函数假设传递的路径参数为 /user/zs+18，可以使用如下代码获取： 1234@app.route(&#x27;/user/&lt;info&gt;&#x27;)def user(info): args = info.split(&quot;+&quot;) return f&quot;获取到信息 &#123;args[0]&#125; 和 &#123;args[1]&#125;&quot; 但是代码 args = info.split(&quot;+&quot;) 只是处理字符串，与业务逻辑没什么关系，将代码修改为： 123456789class LiConverter(BaseConverter): def to_python(self, value): return value.split(&#x27;+&#x27;)app.url_map.converters[&#x27;li&#x27;] = LiConverter@app.route(&#x27;/user/&lt;li:info&gt;&#x27;)def user(info): return f&quot;获取到信息 &#123;info[0]&#125; 和 &#123;info[1]&#125;&quot; 此时 user 函数的参数 info，直接接收到的就是路径 /user/zs+18 处理后的结果。 查询参数的使用网址中在 ? 后面的格式为 key=value 的以 &amp; 作为分割的字符串称为查询参数。 为何叫查询参数？因为无论怎么加查询参数（有用的或者没用的）都不会改变所调用的 API 接口，而这些查询参数会传递到 API 接口内部，就像给函数传递参数一样。 1234567891011@app.route(&#x27;/&#x27;)def index(): # 方法1 uname = request.args.get(&quot;uname&quot;) pwd = request.args.get(&quot;pwd&quot;) #方法2 uname = request.values.get(&quot;uname&quot;) pwd = request.values.get(&quot;pwd&quot;) return f&quot;Hello, &#123;uname&#125;, &#123;pwd&#125;&quot; 此时在浏览器中输入 http://127.0.0.1:5000/?uname=zhuning&amp;pwd=1234后台就可以获取到参数 uname 和 pwd。 查询参数是直接暴露在 url 地址中的，用查询参数发起的请求称为 get 请求。 请求体参数当请求的数据需要隐藏或者数据量较大时，就需要使用请求体参数。 请求体参数是隐藏在数据包中的，使用请求体参数发起的请求称为 post 请求。 123456789101112131415# 将这个 url 地址支持 POST 请求@app.route(&#x27;/login&#x27;, methods=[&#x27;POST&#x27;])def login(): #方法1 uname = request.form.get(&#x27;uname&#x27;) pwd = request.form.get(&#x27;pwd&#x27;) #方法2 uname = request.values.get(&#x27;uname&#x27;) pwd = request.values.get(&#x27;pwd&#x27;) if uname == &#x27;zhangsan&#x27; and pwd == &quot;123456&quot;: return &quot;Hello&quot; else: return &quot;Login failed&quot; 注意在浏览器中输入地址无法发送 POST 请求，此时需要使用 PostMan 模拟 POST 请求。 上传文件文件也需要使用 POST 来发送请求，因此需要使用 PostMan 模拟请求。 1234567@app.route(&#x27;/upload&#x27;, methods=[&#x27;POST&#x27;])def upload(): f = request.files.get(&#x27;pic&#x27;) fname = f.filename with open(f&#x27;./images/&#123;fname&#125;&#x27;, &#x27;wb&#x27;) as tf: tf.write(f.read()) return f&#x27;Hello&#x27; 以上代码可以将文件保存到服务器上。 request 其他参数以下代码可以访问到 request 中的常用参数： 12345678910111213@app.route(&#x27;/args&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def args(): url = request.url method = request.method content_type = request.headers.get(&#x27;Content-Type&#x27;) user_agent = request.headers.get(&#x27;User-Agent&#x27;) cookie = request.cookies.get(&#x27;uuid&#x27;) return f&#x27;&#x27;&#x27; url:&#123;url&#125;, method:&#123;method&#125;\tContent-Type:&#123;content_type&#125;\tUser-Agent:&#123;user_agent&#125;\tCookie:&#123;cookie&#125;\t&#x27;&#x27;&#x27; url_for 函数下面的代码中，当路由地址为 /index 时会找到 home 函数，并执行。 12345678@app.route(&#x27;/index&#x27;)def home(): return f&quot;Hello !!&quot;@app.route(&#x27;/show_url&#x27;)def show_url(): url = url_for(&#x27;home&#x27;) return f&#x27;反向查找到的 URL 地址：&#123;url&#125;&#x27; 此时，url_for 函数的作用是通过 home 这个函数名找到与之绑定的路由地址。 下面的代码时查找需要传递参数的路由地址的情况： 12345678@app.route(&#x27;/home/&lt;int:uid&gt;&#x27;)def home(uid): return f&quot;Hello &#123;uid&#125; !!&quot;@app.route(&#x27;/show_url&#x27;)def show_url(): url = url_for(&#x27;home&#x27;, uid=1001) return f&#x27;反向查找到的 URL 地址：&#123;url&#125;&#x27; 如果代码为： 1url = url_for(&#x27;home&#x27;, uid=1001, addr=&#x27;beijing&#x27;) 此时虽然无法匹配合适的路由地址，但是不会报错，且输出将为 反向查找到的 URL 地址：/home/1001?addr=beijing 即将未匹配到的参数当成查询参数。 注意：在定义url时尽量将最后的斜杠加上，即 1@app.route(&#x27;/show_url/&#x27;) 这是因为如果不加，而在浏览器中输入 http://XXXX:5000/show_url 时将访问不到地址。 响应重定向重定向是响应内容的一种。 两种重定向： 永久重定向：http 状态码为 301 ，比如 www.jingdong.com 现在永久重定向到了 www.jd.com 暂时重定向：http 状态码为 302，如果用户没有登录，需要跳转到登陆页面。 以下代码可以在 Flask 中实现重定向 1234567@app.route(&#x27;/login/&#x27;)def login(): return f&quot;Hello World !!&quot;@app.route(&#x27;/info/&#x27;)def info(): return redirect(&#x27;/login/&#x27;, code=301) 上面代码中的 code 是可选的参数，其值可以是 301 和 302，如果不写该参数，默认值为 302。注意 redirect(&#39;/login/&#39;, code=301) 前面的 return，如果没有会报错。 将 redirect 与 url_for 结合，就可以帮助我们在不修改原始代码的情况下，为某个函数绑定一个新的路由地址。 123@app.route(&#x27;/info/&#x27;)def info(): return redirect(url_for(&#x27;login&#x27;)) 响应类型当使用如下代码响应请求时，返回的响应的类型是 HTML 数据 123@app.route(&#x27;/index/&#x27;)def index(): return &quot;你好呀&quot; 以下代码返回 json 数据： 1234567891011#方法1app.config[&#x27;JSON_AS_ASCII&#x27;] = False@app.route(&#x27;/json1/&#x27;)def r_json(): return &#123;&#x27;key&#x27;: &#x27;Python 语言&#x27;&#125;# 方法2from flask import jsonify@app.route(&#x27;/json2/&#x27;)def r_json2(): return jsonify(&#123;&#x27;key&#x27;: &#x27;Python 语言&#x27;&#125;) 其中 app.config[&#39;JSON_AS_ASCII&#39;] = False 的作用是强制将返回的数据按原样输出。 两个方法的区别是，方法1不支持老版本，方法2支持老版本。 以下代码返回 元组 数据： 1234567891011@app.route(&#x27;/tuple1&#x27;)def r_tuple1(): return &#x27;tuple&#x27;, 202@app.route(&#x27;/tuple2&#x27;)def r_tuple2(): return &#x27;tuple&#x27;, &#123;&#x27;itbaizhan&#x27;:&#x27;python&#x27;&#125;@app.route(&#x27;/tuple3&#x27;)def r_tuple3(): return &#x27;tuple&#x27;, 300, &#123;&#x27;itbaizhan&#x27;:&#x27;python&#x27;&#125; 当返回的数据为元组时，其 要么是 (response, status) 要么是 (response, headers) 要么是 (response, status, headers) 三种中的一种，上面代码中就是依次为这三种情况。 如果包含 headers，则响应头中的数据会被 headers 中的数据替换。 headers 部分除了可以是字典外，还可以是列表，效果是一致的，其写法为： return &#39;tuple&#39;, 300, [(&#39;itbaizhan&#39;, &#39;python&#39;)] 自定义响应对象自定义响应指的是自定义响应内容和响应代码。 123@app.route(&#x27;/&#x27;)def index(): return Response(&quot;你好，少年&quot;, status=500, headers=&#123;&#x27;itbaizhan&#x27;: &#x27;python!!!&#x27;&#125;) 其中，你好，少年、status、 headers都是可选的，如果使用 Response() 则表示响应空的内容。 但如果是空的响应最好写成 Response(status=404)。 为了更友好地表示页面未找到，可以使用 Response(&quot;无法找到页面&quot;, status=404)。 自定义响应对象还可以用如下方式创建： 12345678from flask import make_response@app.route(&#x27;/home/&#x27;)def home(): resp = make_response(&quot;这是创建的 Response 对象&quot;) resp.headers[&#x27;itheima&#x27;] = &quot;SQL+Python&quot; resp.status = 666 return resp","tags":["Python","服务器端","Flask","Web 框架"],"categories":["Python","Web 框架","Flask"]},{"title":"CSS(1) - 初识和基本选择器","path":"/2024/05/10/CSS-1-初识和基本选择器/","content":"CSS 的三种引入方式内嵌式 1234567891011121314&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;title&gt;CSS 三种引入方式&lt;/title&gt; &lt;style&gt; p &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;我是一个 p 标签&lt;/p&gt; &lt;p&gt;我也是一个 p 标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 外联式 12345678910&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;title&gt;CSS 三种引入方式&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css基础.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;我是一个 p 标签&lt;/p&gt; &lt;p&gt;我也是一个 p 标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;123p &#123; color: blue;&#125; 行内式 123456789&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;title&gt;CSS 三种引入方式&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p style=&quot;color: green;&quot;&gt;我是一个 p 标签&lt;/p&gt; &lt;p&gt;我也是一个 p 标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 行内式作用范围最小，优先级最大；外联式作用范围最大，优先级最小。优先级顺序为：行内式 &gt; 内嵌式 &gt; 外联式 标签选择器","tags":["前端","CSS"],"categories":["前端","CSS"]},{"title":"hexo-test","path":"/2024/05/09/hexo-test/","content":"引用块Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing 代码块1alert(&#x27;Hello World!&#x27;); 1[rectangle setX: 10 y: 10 width: 20 height: 20]; Array.map1array.map(callback[, thisArg]) _.compactUnderscore.js12_.compact([0, 1, false, 2, &#x27;&#x27;, 3]);=&gt; [1, 2, 3] 彩色代码块 推荐的写法123func test() &#123; // ...&#125; 不推荐的写法123func test() -&gt; () &#123; // ...&#125;"},{"title":"HTML 基础知识","path":"/2024/05/09/HTML-基础内容/","content":"第一章 HTML 初识Web 标准中将网页分为结构，表现和行为三个部分。 其中，结构由 HTML 表示，表现由 CSS 表示，行为由 JavaScript 表示。 HTML 文件本质是一个文本文件，但是其后缀名为 .html。 第二章 HTML 注释和标签HTML 的基本结构 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;网页的标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 网页的主体内容 &lt;/body&gt;&lt;/html&gt; HTML 两种注释 注释是程序员书写的，给自己或者他人看的，用于说明代码功能的文字。注释不会对代码有任何影响。 12345&lt;!-- 单行注释 --&gt;&lt;!-- 多行注释多行注释多行注释 --&gt; HTML 的注释是不能嵌套的，比如如下注释是错误的： 1234&lt;!-- 单行注释 &lt;!-- 单行注释 --&gt; --&gt; HTML 标签有双标签和单标签两种。 双标签：由开始标签和结束标签及其中包裹的内容组成，比如 &lt;strong&gt;内容&lt;/strong&gt;; 单标签：只由一个部分组成，如&lt;br&gt;、&lt;hr&gt;。 HTML 标签的属性都是包含在开始标签中的，每个属性由属性名和属性值组成，如&lt;strong class=&quot;one&quot;&gt;内容&lt;/strong&gt;。 第三章 HTML 常用标签标题标签标题标签有以下 6 种： 123456&lt;h1&gt;1级标题&lt;/h1&gt;&lt;h2&gt;2级标题&lt;/h2&gt;&lt;h3&gt;3级标题&lt;/h3&gt;&lt;h4&gt;4级标题&lt;/h4&gt;&lt;h5&gt;5级标题&lt;/h5&gt;&lt;h6&gt;6级标题&lt;/h6&gt; 这些标签有加粗效果，从 h1 - h6 文字逐渐减小，均独占一行。 段落标签段落标签只有一个 1&lt;p&gt;我是一段文字&lt;/p&gt; 段落标签独占一行，对文字格式没有明显改变，段落之间有间隙。 换行标签、水平线标签换行标签、水平线标签都是单标签，各有一个 12&lt;br&gt; &lt;!-- 换行标签 --&gt;&lt;hr&gt; &lt;!-- 水平线标签 --&gt; 文本格式化标签主要功能是为文字添加加粗、下划线、倾斜、删除等效果。 1234567891011&lt;b&gt;加粗&lt;/b&gt;&lt;u&gt;下划线&lt;/u&gt;&lt;i&gt;倾斜&lt;/i&gt;&lt;s&gt;删除线&lt;/s&gt;&lt;br&gt;&lt;strong&gt;加粗&lt;/strong&gt;&lt;ins&gt;下划线&lt;/ins&gt;&lt;em&gt;倾斜&lt;/em&gt;&lt;del&gt;删除线&lt;/del&gt; 主要功能是突出显示。 其中第二组标签语义更加强烈，因此推荐使用。 图片标签图片标签是最常用的媒体标签，用于展示图片，是单标签。 1234567&lt;img src=&quot;文件路径&quot; alt=&quot;当图片加载失败时，展示的文本，如果加载成功则不显示&quot; title=&quot;当鼠标悬停在图片上时，显示的文本&quot; width=&quot;填写数字，单位像素，但书写时不带单位，如果width和height只设置一个则等比例缩放，如果width和height都设置可能会导致图片变形&quot; height=&quot;800&quot;&gt; 相对路径和绝对路径相对路径用的多。要着重认识。 绝对路径：从盘符开始的路径； 相对路径：从当前文件位置开始查找的路径； ./：表示同级目录； XXX/：表示XXX的下级目录； ../：表示上级目录； 第四章 HTML 其他标签音频标签音频标签是双标签，其中 src 属性是必须的 123456&lt;audio src=&quot;音频文件的路径&quot; controls autoplay loop &gt;&lt;/audio&gt; 其中，controls 属性表示是否显示播放控件； autoplay 属性表示是否自动播放； loop 属性表示是否循环播放； controls、autoplay、loop 属性默认没有属性值 视频标签视频标签是双标签，其属性与音频标签完全一致； 123456&lt;video src=&quot;音频文件的路径&quot; controls autoplay loop &gt;&lt;/video&gt; 超链接标签超链接标签是双标签， 1234&lt;a href=&quot;./目标网页.html&quot; target=&quot;点击超链接标签时，打开网页的方式&quot; &gt;超链接&lt;/a&gt; target 属性的属性值： “_self”：表示在原窗口跳转； “_blank”：表示在新窗口跳转； 超链接标签原始样式为蓝字、下划线； 未点击过时，默认颜色为蓝色；点击过后，为紫色； 1234&lt;a href=&quot;./目标网页.html&quot; target=&quot;点击超链接标签时，打开网页的方式&quot; &gt;超链接&lt;/a&gt; 这样的链接叫做空链接： 作用1：回到网页顶部； 作用2：当跳转的页面还没确定时，用作占位。 第五章 列表与表格列表分无序列表、有序列表、自定义列表，这 3 者在显示上有区别，但实际应用这 3 者的区别主要在语义上。 无序列表语义上表示没有顺序之分 12345&lt;ul&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt;&lt;/ul&gt; 注意：ul 标签中只能包含 li 标签，但 li 标签中可以包含任何标签。 有序别表语义上表示有顺序 12345&lt;ol&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt;&lt;/ol&gt; 注意：ol 标签中只能包含 li 标签，但 li 标签中可以包含任何标签。 自定义列表主要用于表示一个标题、多个项目这样的结构 123456&lt;dl&gt; &lt;dt&gt;帮助中心（列表主题）&lt;/dt&gt; &lt;dd&gt;账号管理（列表内容）&lt;/dd&gt; &lt;dd&gt;购物指南（列表内容）&lt;/dd&gt; &lt;dd&gt;订单操作（列表内容）&lt;/dd&gt;&lt;/dl&gt; 注意：dl 标签中只能包含 dt、dd 标签，但 dt、dd 标签中可以包含任何标签。 表格标签1234567891011&lt;table border=&quot;1&quot; width=&quot;100&quot; height=&quot;100&quot;&gt; &lt;caption&gt;表格题目&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;标题1&lt;/th&gt; &lt;th&gt;标题2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;内容1&lt;/td&gt; &lt;td&gt;内容2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 其中， caption 应该放在 table 标签的一开始； table 标签中可以包含 tr 标签； tr 标签中可以包含 th、td 标签： th 标签（table head）用于表头单元格的内容； td 标签用于表格内容单元格。 border 属性表示边框的宽度，width、height 用于设置高度和宽度， 这三个属性可以用于 table、th、tr、td 标签，用于不同标签时其作用范围不同。 除了上述内容外，表格还有 3 个结构标签，thead、tbody、tfoot，这 3 个标签用于表示表格各部分的语义特征，用法如下： 1234567891011121314&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;标题1&lt;/th&gt; &lt;th&gt;标题2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;内容1&lt;/td&gt; &lt;td&gt;内容2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; rowspan、colspan 属性用于合并单元格，这两个属性应写在td 标签中 注意：1、rowspan 是在垂直方向上合并，colspan 是在水平方向上合并； ​ 2、rowspan、colspan 不能跨结构标签，即不能跨 thead、tbody、tfoot 这 3 个标签。 第六章 表单标签input 系列标签input 标签最主要的是 type 属性，其属性值如下： 12345678910111213141516&lt;!-- 1、文本框：type=&quot;text&quot; --&gt;昵称: &lt;input type=&quot;text&quot; value=&quot;123123&quot;&gt; &lt;br&gt;&lt;!-- 2、密码框：type=&quot;password&quot; --&gt;密码: &lt;input type=&quot;password&quot; value=&quot;123123&quot;&gt; &lt;br&gt;&lt;!-- 3、单选框：type=&quot;radio&quot; 多个单选框只能有一个被选中 --&gt;性别：&lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;gender&quot;&gt;女 &lt;br&gt;&lt;!-- 4、复选框：type=&quot;checkbox&quot; --&gt;爱好: &lt;input type=&quot;checkbox&quot;&gt;敲代码&lt;input type=&quot;checkbox&quot;&gt;玩游戏 &lt;br&gt;&lt;!-- 5、文件选择框：type=&quot;file&quot; --&gt;&lt;input type=&quot;file&quot;&gt; &lt;br&gt;&lt;!-- 6、按钮：按钮的属性值有 3 个，分别为：submit、reset、button --&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;普通按钮&quot;&gt; type&#x3D;”text” 的 input 标签为文本框： 属性 placeholder&#x3D;”XXX” 用于显示提示内容。 type&#x3D;”password” 的 input 标签为密码框： 属性 placeholder&#x3D;”XXX” 用于显示提示内容。 type&#x3D;”radio” 的 input 标签为单选框： 属性 name&#x3D;”XXX” 表示，name 相同的多个单选框为一组，一组单选框中只有 1 个单选框会被选中； checked 属性默认没有属性值，其表示某个单选框是否为选中状态，同一组单选框中的多个单选框如果都设置了 checked 则最后一个单选框被选中。 type&#x3D;”checkbox” 的 input 标签为复选框： checked 属性默认没有属性值，其表示某个复选框是否为选中状态。 type&#x3D;”file” 的 input 标签为文件选择框： multiple 属性默认没有属性值，表示是否可以选择多个文件。 一般来说，所有 input 标签都应该包含在 标签中。 字符实体空格合并：在 HTML 代码中连续出现多个空格、换行、缩进时，在显示时都会被压缩成一个空格； 使用字符实体可解决该问题 常见的字符实体有： 第七章 作业制作下面的表格： 制作下面的页面：","tags":["HTML","前端"],"categories":["前端","HTML"]}]